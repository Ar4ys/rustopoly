#![feature(extract_if)]

use std::{
    convert::identity,
    env, future,
    net::{Ipv4Addr, SocketAddrV4},
};

use futures::StreamExt;
use shared::{backend::Backend, frontend::FrontendClient, spawn_two_way};
use tarpc::{client, serde_transport, server::Channel, tokio_serde::formats::Json};

use crate::server::BackendServer;

mod server;

static DEFAULT_SERVER_PORT: &str = "3500";

#[tokio::main]
pub async fn main() {
    let server_address = SocketAddrV4::new(
        Ipv4Addr::LOCALHOST,
        env::var("SERVER_PORT")
            .unwrap_or(DEFAULT_SERVER_PORT.into())
            .parse()
            .expect("$SERVER_PORT should be a valid port"),
    );

    println!("Starting server on {}", server_address);

    let mut listener = serde_transport::tcp::listen(server_address, Json::default)
        .await
        .unwrap();

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(spawn_two_way)
        .map(|(server_transport, client_transport)| {
            let player_client =
                FrontendClient::new(client::Config::default(), client_transport).spawn();
            tarpc::server::BaseChannel::with_defaults(server_transport)
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated World trait.
                .execute(BackendServer::new(player_client).serve())
                .for_each(identity)
        })
        .for_each(identity)
        .await;
}
